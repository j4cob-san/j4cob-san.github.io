<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Starfield</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Matrix characters
        const chars = 'ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        // Title configuration
        const titleLines = [
            "Jasmine & Jacob's Wedding",
            "July 25th 2026"
        ];
        
        const titlePositions = [];
        
        // Calculate title character positions
        function calculateTitlePositions() {
            titlePositions.length = 0;
            const fontSize = 52;
            const lineHeight = fontSize * 1.6;
            const startY = canvas.height / 2 - (titleLines.length * lineHeight) / 2 + fontSize;
            
            titleLines.forEach((line, lineIndex) => {
                ctx.font = `bold ${fontSize}px "Courier New"`;
                const lineWidth = ctx.measureText(line).width;
                const startX = canvas.width / 2 - lineWidth / 2;
                
                let currentX = startX;
                for (let char of line) {
                    const charWidth = ctx.measureText(char).width;
                    titlePositions.push({
                        char: char,
                        x: currentX + charWidth / 2,
                        y: startY + lineIndex * lineHeight,
                        locked: null
                    });
                    currentX += charWidth;
                }
            });
        }
        
        calculateTitlePositions();
        
        class MatrixStar {
            constructor() {
                this.reset();
            }
            
            reset() {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 500;
                
                this.x = Math.cos(angle) * distance;
                this.y = Math.sin(angle) * distance;
                this.z = Math.random() * 2000 + 1000;
                
                this.char = chars[Math.floor(Math.random() * chars.length)];
                this.trail = [];
                this.trailLength = Math.floor(Math.random() * 5) + 3;
                
                for (let i = 0; i < this.trailLength; i++) {
                    this.trail.push(chars[Math.floor(Math.random() * chars.length)]);
                }
                
                this.speed = Math.random() * 3 + 2;
                this.changeCharInterval = Math.floor(Math.random() * 5) + 3;
                this.frameCount = 0;
                this.isLocked = false;
                this.targetPos = null;
            }
            
            update() {
                if (this.isLocked) return;
                
                this.z -= this.speed * 2;
                
                this.frameCount++;
                if (this.frameCount % this.changeCharInterval === 0) {
                    this.char = chars[Math.floor(Math.random() * chars.length)];
                    if (Math.random() > 0.7) {
                        const idx = Math.floor(Math.random() * this.trail.length);
                        this.trail[idx] = chars[Math.floor(Math.random() * chars.length)];
                    }
                }
                
                if (this.z < 1) {
                    this.reset();
                }
            }
            
            checkTitleCollision() {
                if (this.isLocked) return;
                
                const scale = 1000 / this.z;
                const x = this.x * scale + canvas.width / 2;
                const y = this.y * scale + canvas.height / 2;
                
                for (let pos of titlePositions) {
                    if (pos.locked) continue;
                    
                    const dx = x - pos.x;
                    const dy = y - pos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 30 && this.z < 100) {
                        this.isLocked = true;
                        this.targetPos = pos;
                        this.char = pos.char;
                        pos.locked = this;
                        return;
                    }
                }
            }
            
            draw() {
                if (this.isLocked && this.targetPos) {
                    // Draw locked character at title position with CRT glow
                    const size = 52;
                    
                    // Outer glow layers for CRT effect
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.6)';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';
                    ctx.font = `bold ${size}px "Courier New"`;
                    ctx.fillText(this.char, this.targetPos.x, this.targetPos.y);
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.fillText(this.char, this.targetPos.x, this.targetPos.y);
                    
                    // Bright core
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = '#00ff00';
                    ctx.fillText(this.char, this.targetPos.x, this.targetPos.y);
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                    return;
                }
                
                const scale = 1000 / this.z;
                const x = this.x * scale + canvas.width / 2;
                const y = this.y * scale + canvas.height / 2;
                
                // Early exit for off-screen stars
                if (x < -100 || x > canvas.width + 100 || y < -100 || y > canvas.height + 100) {
                    return;
                }
                
                const size = (1 - this.z / 3000) * 20 + 8;
                const alpha = 1 - this.z / 3000;
                
                // Only draw trails for closer stars
                if (this.z < 1000) {
                    for (let i = 0; i < this.trail.length; i++) {
                        const trailAlpha = alpha * (1 - i / this.trail.length) * 0.5;
                        const trailSize = size * (1 - i / this.trail.length * 0.5);
                        
                        const trailZ = this.z + (i + 1) * 30;
                        const trailScale = 1000 / trailZ;
                        const trailX = this.x * trailScale + canvas.width / 2;
                        const trailY = this.y * trailScale + canvas.height / 2;
                        
                        ctx.fillStyle = `rgba(0, ${100 + Math.floor(trailAlpha * 155)}, 0, ${trailAlpha})`;
                        ctx.font = `${trailSize}px "Courier New"`;
                        ctx.fillText(this.trail[i], trailX, trailY);
                    }
                }
                
                // Draw main character
                ctx.fillStyle = `rgba(200, 255, 200, ${alpha})`;
                ctx.font = `bold ${size}px "Courier New"`;
                ctx.fillText(this.char, x, y);
                
                // Only add glow to very close stars
                if (this.z < 300) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = `rgba(150, 255, 150, ${alpha * 0.5})`;
                    ctx.fillText(this.char, x, y);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        const stars = [];
        const maxStars = window.innerWidth < 768 ? 100 : 150;
        
        for (let i = 0; i < maxStars; i++) {
            stars.push(new MatrixStar());
        }
        
        function animate() {
            // Faster fade for better performance
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < stars.length; i++) {
                stars[i].update();
                stars[i].checkTitleCollision();
                stars[i].draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                calculateTitlePositions();
            }, 250);
        });
        
        animate();
    </script>
</body>
</html>
